C4TF Writeup; automating CMP-based flags

# --------------
# Please enter the commit message for your changes. Everything below
# this paragraph is ignored, and an empty message aborts the commit.
# Just close the window to accept your message.
diff --git a/_posts/2017-06-12-CircleCityCon-Russia.md b/_posts/2017-06-12-CircleCityCon-Russia.md
new file mode 100644
index 0000000..0deb2d6
--- /dev/null
+++ b/_posts/2017-06-12-CircleCityCon-Russia.md
@@ -0,0 +1,62 @@
+---
+layout: default
+---
+# Circle City Con CTF (C4TF)
+## Russia - Let's Compare Ourselves
+
+Binary: [russia](https://ginjabenjamin.github.io/objects/2017-06-12-CircleCityCon-Russia/russia)
+Solution: [auto-cmp.py](https://ginjabenjamin.github.io/objects/2017-06-12-CircleCityCon-Russia/auto-cmp.py)
+
+## Challange
+
+### Type: 
+Reverse Engineering
+
+#### File: 
+russia: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=f974aef4a26e61c61a5e4efa8b56669f1e01916c, stripped
+
+#### Protections:
+CANARY    : disabled
+FORTIFY   : disabled
+NX        : ENABLED
+PIE       : disabled
+RELRO     : Partial
+
+
+## TL;DR
+Break at 0x004006dd, examine RAX to brute the 32 flag characters.
+
+## Analysis
+If no arguments are passed, usage is output:
+```
+Usage: ./russia <flag>
+```
+
+Executable expects a flag argument to be passed. We see this at 0x00400606, which is looking for one commandline argument, or the program branches, shows usage and exits.
+
+Early in main(), we also see a compare instruction after a strlen() call:
+
+```
+  400645:   bf e0 07 40 00          mov    edi,0x4007e0
+  40064a:   e8 61 fe ff ff          call   4004b0 <strlen@plt>
+  40064f:   48 39 c3                cmp    rbx,rax
+```
+
+Breaking at 0x0040064f we can determine that the condition we need to meet is 32. Sure enough, passing a flag of 32 characters, we get further into the program, arriving at the algorithm where the magic happens.
+
+[Algorithm]: https://ginjabenjamin.github.io/objects/2017-06-12-CircleCityCon-Russia/russia.png "Russian Algorithms"
+
+In the 0x00400690 block, we see some math/logic operations, and ultimately a compare operation (0x004006dd) against EAX and EDX. By stepping though, we determine that RAX (EAX for CMP) is the current character (as determined from the counter variable RDP-0x14) from our input string and RDX (EDX for CMP) is the current target flag character.
+
+# In Soviet Russia, Flag Solves You
+## Or, How I learned to Resent Pwntools and Automate the Comparison
+This is a good example of a common reversing engineering challenge that is easier to  brute force than reverse the alogrithm. In the past, I had tried to automate these to make time for more complex challenges. I wanted a Pwntools script to:
+1. Fire off GDB
+2. Setup a breakpoint on CMP operation
+3. Display the target/desired value
+
+Unfortunately, pwn.gdb.attach() has some issues. Ther are a few writeups that appear to use it simplistically, but trying to grab the output was not working for me. I tried logging, STDOUT redirection, teeing... No luck. Attach does not appear to return the tube that it is supposed to; we cannot fully interact with it like a normal process. Furthermore, when your debugging process finishes, pwntools does not recognize that it ends and sits there waiting, leaving the reported process as defunct. The 'waiting for debugger' should only show when waiting on the process, but the process has already completed, with our desired output flashing by and not ending up in a log or output file. So it looks like pwntools may be waiting on the wrong process. Once a couple teammates told me that they had failed to get pwn.gdb.attach() working in the past, I pursued another solution.
+
+I found a [HackYou CTF writeup](https://blog.w3challs.com/?post/2012/10/13/HackYou-CTF-Reverse100%2C-Reverse200%2C-Reverse300-Writeups) that included a pythonGDB script that does exactly what I was looking for. After adjusting the script to work for me, I then made a wrapper Python script to generate the the pythonGDB script(s) based on all register-based compare operations for a specified binary. Still a bit manual, but no matter what these require a bit of actual analysis. In any event, [auto-cmp.py](https://ginjabenjamin.github.io/objects/2017-06-12-CircleCityCon-Russia/auto-cmp.py) has some reusability. 
+
+That said, I would really like to finish the pwntool approach. If anyone has a solution...
\ No newline at end of file
diff --git a/objects/2017-06-12-CircleCityCon-Russia/auto-cmp.py b/objects/2017-06-12-CircleCityCon-Russia/auto-cmp.py
new file mode 100644
index 0000000..be6ab52
--- /dev/null
+++ b/objects/2017-06-12-CircleCityCon-Russia/auto-cmp.py
@@ -0,0 +1,81 @@
+'''
+Generates scripts to be executed with gdb that break on CMP instructions
+and set compared values equal to each other so that flags can be bruteforced
+
+Resulting try*.py files need to be executed against binary using:
+    # gdb [binary] -x try[address].py
+    gdb$ run
+
+    -or-
+
+    # gdb [binary]
+    gdb$ source try[address].py
+    gdb$ run
+'''
+import os
+import re
+import subprocess
+import sys
+
+if(len(sys.argv) < 2):
+    print('Usage: %s [binary]' % sys.argv[0])
+    exit()
+else:
+    binary = sys.argv[1]
+
+    if(binary[0] != '.' and binary[0] != '/'):
+        binary = './' + binary
+
+print('Targeting: {}'.format(binary))
+
+script = '''flag = ""
+ 
+def changeInputChar():
+    global flag
+ 
+    gdb.execute("set ${}=${}")
+ 
+    flag += chr(gdb.parse_and_eval("$eax"))
+ 
+    print("[+]", flag)
+
+class HitBreakpoint(gdb.Breakpoint):
+    def __init__(self, loc, callback):
+        super(HitBreakpoint, self).__init__(
+            loc, gdb.BP_BREAKPOINT, internal=False
+        )
+        self.callback = callback
+ 
+    def stop(self):
+        self.callback()
+ 
+        return False
+ 
+HitBreakpoint("*0x{}", changeInputChar)'''
+
+# Find references to CMP and limit to those that are comparing two registers.
+# Use the address for breakpoints, and use the compared registers in a set
+# operation to brute force the 'flag'
+cmd = "objdump --no-show-raw-insn -M intel -d " + binary
+cmd += " | grep -e '[[:alnum:]]*:.*cmp\s*[er]\w\w,[er]\w\w'"
+
+# Sed doesn't play nice and encode() didn't fix it
+# cmd += " | sed 's/^[[:blank:]]*\([[:alnum:]]*\):\s*cmp\s*\(\w\w\w\),\(\w\w\w\)/"
+# cmd += "\1,\3,\2/'"
+
+p = subprocess.Popen([cmd], stdout=subprocess.PIPE, shell=True)
+cmp = p.stdout.read()
+
+# Because sed sucks...
+cmp = re.sub(r':\s+cmp\s+', ',', cmp)
+
+# Generate a script for each CMP
+for l in cmp.split('\n'):
+    # Break instruction into list {address, target, input}
+    i = l.lstrip().split(',')
+
+    if(len(i[0])):
+        print('[+] Writing: try' + i[0] + '.py')
+        f = open('try' + i[0] + '.py', 'w')
+        f.write(script.format(i[2], i[1], i[0]))
+        f.close
diff --git a/objects/2017-06-12-CircleCityCon-Russia/failing-russia-solve.py b/objects/2017-06-12-CircleCityCon-Russia/failing-russia-solve.py
new file mode 100644
index 0000000..7a8f751
--- /dev/null
+++ b/objects/2017-06-12-CircleCityCon-Russia/failing-russia-solve.py
@@ -0,0 +1,37 @@
+from pwn import *
+
+breakAddress = 0x004006dd       # Address with compare instruction
+targetRegister = '$rdx'         # Value that we want to identify
+
+breakCommand = '''set logging file russian.log
+set logging on
+break *{}
+command 1
+# Commenting silent out breaks output (print statements do not display)
+silent
+print {}
+continue
+end
+'''.format(breakAddress, targetRegister)
+
+# Characters to use for bruting flag
+chars = [chr(x) for x in range(41, 126)]
+
+flag = 'a'*32
+
+p = process('./russia')
+
+print('-'*80)
+d = gdb.attach(
+    p, 
+    gdbscript=breakCommand, 
+    exe='./russia') 
+
+d.send('run '+flag+'\n')
+d.recv(timeout=1.0)
+d.close()
+
+# This does nothing; hangs on 'waiting for debugger'
+# even though ps shows process as defunct
+#d.close()
+
diff --git a/objects/2017-06-12-CircleCityCon-Russia/russia b/objects/2017-06-12-CircleCityCon-Russia/russia
new file mode 100755
index 0000000..c4fae5b
Binary files /dev/null and b/objects/2017-06-12-CircleCityCon-Russia/russia differ
diff --git a/objects/2017-06-12-CircleCityCon-Russia/russia.png b/objects/2017-06-12-CircleCityCon-Russia/russia.png
new file mode 100644
index 0000000..4636744
Binary files /dev/null and b/objects/2017-06-12-CircleCityCon-Russia/russia.png differ